using System;
using System.Linq;
using System.Text;
using CuriousInc.Source.Generators.Utilities.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CuriousInc.Source.Generators.Utilities;

[Generator]
public class UnionSourceGenerator : IIncrementalGenerator
{
    private const string AttributeName = "UnionTypeAttribute";

    private const string AttributeCode = $"""
                                          using System;
                                          namespace Headquarters.Utilities.SourceGenerators.Attributes;

                                          [AttributeUsage(AttributeTargets.Struct)]
                                          public sealed class UnionTypeAttribute : Attribute;
                                          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource($"{AttributeName}.g.cs", SourceText.From(AttributeCode, Encoding.UTF8)));

        var candidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => s is RecordDeclarationSyntax rs
                                 && rs.ClassOrStructKeyword.IsKind(SyntaxKind.StructKeyword)
                                 && rs.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword))
                                 && rs.Modifiers.Any(m => m.IsKind(SyntaxKind.ReadOnlyKeyword)),
                static (ctx, _) =>
                {
                    var sds = (RecordDeclarationSyntax)ctx.Node;

                    return new SyntaxProviderCandidate
                    {
                        Symbol = ctx.SemanticModel.GetDeclaredSymbol(sds),
                        Syntax = sds
                    };
                })
            .Where(static x => x is { Symbol: not null })
            .Where(static t => HasAttribute(t.Symbol!, AttributeName));

        var partials = GeneratePartialType(candidates);

        context.RegisterSourceOutput(partials, static (spc, item) =>
        {
            var root = CSharpSyntaxTree.ParseText(item.Source).GetRoot();
            var pretty = root.NormalizeWhitespace().ToFullString();

            spc.AddSource(item.Hint,
                SourceText.From(pretty, Encoding.UTF8));
        });
    }

    private static bool HasAttribute(INamedTypeSymbol symbol, string simpleName)
    {
        foreach (var attr in symbol.GetAttributes())
        {
            var name = attr.AttributeClass?.Name;
            if (name is null) continue;

            // Matches StronglyTypedId or StronglyTypedIdAttribute
            if (name.Equals(simpleName, System.StringComparison.Ordinal) ||
                name.Equals(simpleName + "Attribute", System.StringComparison.Ordinal))
            {
                return true;
            }
        }

        return false;
    }

    private static IncrementalValuesProvider<GenerateSource> GeneratePartialType(
        IncrementalValuesProvider<SyntaxProviderCandidate> candidates)
    {
        return candidates.Select(static (t, _) =>
        {
            var (symbol, _, _) = t;
            var ns = symbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : symbol.ContainingNamespace.ToDisplayString();

            var typeName = symbol.Name;
            var arity = symbol.Arity < 2
                ? throw new ArgumentOutOfRangeException($"{typeName} needs more generics.")
                : symbol.Arity;
            
            var list = Enumerable.Range(1, arity).ToList();

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine();
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("""
                          using System;
                          using System.Diagnostics;
                          using System.Diagnostics.CodeAnalysis;
                          using System.Text.Json;
                          using System.Text.Json.Serialization;
                          using Headquarters.Utilities.SourceGenerators.Attributes;
                          """);
            sb.AppendLine();

            if (ns is not null)
            {
                sb.AppendLine($"namespace {ns};");
                sb.AppendLine();
            }

            var genericTypeDefinitions = $"Union<{string.Join(", ", list.Select(number => $"T{number}").ToList())}>";
            var matchFunctionParameters = string.Join(", ", list.Select(number => $"Func<T{number}, TResult> func{number}").ToList());
            
            var ctors = new StringBuilder();
            var fields = new StringBuilder();
            var properties = new StringBuilder();
            var variantTag = new StringBuilder();
            var tryGetVals = new StringBuilder();
            var unwraps = new StringBuilder();
            var matchFunction = new StringBuilder();
            var applyMethods = new StringBuilder();
            var implicitOperators = new StringBuilder();
            
            foreach (var number in list)
            {
                implicitOperators.AppendLine($"public static implicit operator {genericTypeDefinitions}(T{number} value) => new(value);");
                implicitOperators.AppendLine($"public static implicit operator T{number}({genericTypeDefinitions} value) => value.T{number}Value;");
                matchFunction.AppendLine($"Variant.T{number} => func{number}(_t{number}!),");
                fields.AppendLine($"private readonly T{number}? _t{number} = default;");
                properties.AppendLine($"public readonly T{number} T{number}Value => _t{number}!;");
                variantTag.AppendLine($"T{number} = {number},");
                ctors.AppendLine($"private Union(T{number} value) => (_tag, _t{number}) = (Variant.T{number}, value);");

                tryGetVals.AppendLine($$"""
                                      public bool TryGetValue(out T{{number}}? value)
                                      {
                                         var (result, temp) = _tag switch 
                                         {
                                            Variant.T{{number}} => (true, _t{{number}}),
                                            _ => (false, default)
                                         };
                                          
                                          value = temp;
                                          
                                          return result;
                                      }
                                      """);
                unwraps.AppendLine($$"""
                                     public T{{number}} UnwrapT{{number}}() => _tag switch
                                     {
                                        Variant.T{{number}} => _t{{number}}!,
                                        _ => throw new IndexOutOfRangeException("T{{number}} is null.")
                                     };

                                     public T{{number}} UnwrapT{{number}}OrElse(T{{number}} defaultValue) => _tag switch
                                     {
                                        Variant.T{{number}} => _t{{number}}!,
                                        _ => defaultValue
                                     };
                                     """);

                applyMethods.AppendLine($$"""
                                        public {{genericTypeDefinitions}} Apply(Func<T{{number}}, {{genericTypeDefinitions}}> functor) => _tag switch
                                        {
                                            Variant.T{{number}} => functor(_t{{number}}!),
                                            _ => throw new ArgumentNullException()
                                        };
                                        """);
            }
            
            sb.AppendLine($"public readonly partial record struct {genericTypeDefinitions}");
            sb.AppendLine("{ // Begin Union class");

            sb.AppendLine("private enum Variant : byte");
            sb.AppendLine("{");
            sb.AppendLine("None = 0,");
            sb.AppendLine(variantTag.ToString());
            sb.AppendLine("}");

            sb.AppendLine();
            sb.AppendLine("private readonly Variant _tag = Variant.None;");
            sb.AppendLine(fields.ToString());
            sb.AppendLine(properties.ToString());
            
            sb.AppendLine();
            sb.AppendLine(ctors.ToString());
            sb.AppendLine(implicitOperators.ToString());
            sb.AppendLine(tryGetVals.ToString());
            sb.AppendLine(unwraps.ToString());
            
            sb.AppendLine($$"""
                            public TResult Match<TResult>({{matchFunctionParameters}}) => _tag switch
                            {
                            {{ matchFunction }}
                             _ => throw new ArgumentOutOfRangeException($"{_tag} could not be found.")
                            };
                            """);

            sb.AppendLine(applyMethods.ToString());
            sb.AppendLine("} // End of Union Class");
            

            var source = sb.ToString();
            var hintName = $"{typeName}.{arity}.g.cs";

            return new GenerateSource(hintName, source);
        });
    }
    
    private static string MakeSingleTrueTuplePattern(int arity, int trueIndex)
    {
        return "(" + string.Join(", ",
            Enumerable.Range(1, arity)
                .Select(i => i == trueIndex ? "true" : "false")) + ") => null!";
    }
}