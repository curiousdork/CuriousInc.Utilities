using System.Collections.Generic;
using System.Linq;
using System.Text;
using CuriousInc.Utilities.Source.Generators.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CuriousInc.Utilities.Source.Generators;

[Generator]
public sealed class ValueObjectGenerator : IIncrementalGenerator
{
    private const string AttributeName = "ValueObjectAttribute";

    private const string AttributeCode = $$"""
                                         using System;
                                         namespace CuriousInc.Utilities.Source.Generators.Attributes;
                                         
                                         [AttributeUsage(AttributeTargets.Class)]
                                         public sealed class {{AttributeName}} : Attribute;
                                         """;
    
    private const string AttributeFileName = $"{AttributeName}.g.cs";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(AttributeFileName,
            SourceText.From(AttributeCode, Encoding.UTF8)));
        
        var candidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => s is RecordDeclarationSyntax rs
                                 && rs.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)),
                static (ctx, _) =>
                {
                    var sds = (RecordDeclarationSyntax)ctx.Node;

                    return new SyntaxProviderCandidate
                    {
                        Symbol = ctx.SemanticModel.GetDeclaredSymbol(sds),
                        Syntax = sds
                    };
                })
            .Where( static x => x is { Symbol: not null })
            .Where(static t => HasAttribute(t.Symbol!, AttributeName));
        
        var partials = GeneratePartials(candidates);
        
        context.RegisterSourceOutput(partials, static (spc, item) =>
        {
            var root = CSharpSyntaxTree.ParseText(item.Source).GetRoot();
            var pretty = root.NormalizeWhitespace().ToFullString();
            spc.AddSource(item.Hint, SourceText.From(pretty, Encoding.UTF8));
        });
    }

    private static bool HasAttribute(INamedTypeSymbol symbol, string simpleName)
    {
        foreach (var attr in symbol.GetAttributes())
        {
            var name = attr.AttributeClass?.Name;
            if (name is null) continue;

            // Matches StronglyTypedId or StronglyTypedIdAttribute
            if (name.Equals(simpleName, System.StringComparison.Ordinal) ||
                name.Equals(simpleName + "Attribute", System.StringComparison.Ordinal))
            {
                return true;
            }
        }
        return false;
    }

    private static IncrementalValuesProvider<GenerateSource> GeneratePartials(
        IncrementalValuesProvider<SyntaxProviderCandidate> candidates)
    {
        return candidates.Select(static (spc, _) =>
        {
            var (symbol, syntax, _) = spc;
            var ns = symbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : symbol.ContainingNamespace.ToDisplayString();

            var typeName = symbol.Name;
            List<string> parameterNames = [];
            StringBuilder debuggerDisplay = new();
            
            foreach (var parameter in syntax.ParameterList.Parameters)
            {
                parameterNames.Add(parameter.Identifier.Text);
                debuggerDisplay.AppendFormat("#{0}: {{{1}}} ", parameter.Identifier.Text,
                    parameter.Identifier.ValueText);
            }

            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine();
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("""
                          using System;
                          using System.Diagnostics;
                          using System.Diagnostics.CodeAnalysis;
                          using System.Text.Json;
                          using System.Text.Json.Serialization;
                          using CuriousInc.Utilities.Source.Generators.Attributes;
                          """);
            sb.AppendLine();

            if (ns is not null)
            {
                sb.AppendLine($"namespace {ns};");
                sb.AppendLine();
            }

            sb.AppendLine($$"""
                            // [JsonConverter(typeof({{typeName}}JsonConverter))]
                            [DebuggerDisplay("{DebuggerDisplay,nq}")]
                            public partial record {{typeName}}
                            {
                                public IEnumerable<object?> GetEqualityComponents()
                                {
                                    return [{{ string.Join(", ", parameterNames) }}];
                                }
                                
                                private string DebuggerDisplay => "{{debuggerDisplay}}";
                            }
                            """);
            
            var source = sb.ToString();
            var hintName = $"{typeName}.g.cs";

            return new GenerateSource(hintName, source);
        });
    }
}